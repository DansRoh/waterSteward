{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// cropper/cropper.js\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    /**\r\n     * @type         number\r\n     * @description  组件裁剪显示区域的最大比例，如果裁剪的图片过长，则做限制，默认最大宽高比例为 宽640 / 高960 (宽高比例)\r\n     * @example 1    如果CROPPER_WIDTH宽度是720px，那么裁剪区域的高度也就是 CROPPER_WIDTH / cropperRatio 为 720px;\r\n     */\r\n    cropperRatio: {\r\n      type: Number,\r\n      value: 0.7\r\n    },\r\n\r\n    /**\r\n     * @type         number\r\n     * @description  初始化的裁剪比例\r\n     * @example 0    默认初始化的裁剪区域宽高为图片的宽高，且裁剪比例不固定\r\n     * @example 0.5  宽高比例固定，且宽和高的比例为 1 : 2 的比例\r\n     * @example 2    宽高比例固定，且宽和高的比例为 2 : 1 的比例\r\n     */\r\n    cutRatio: {\r\n      type: Number,\r\n      value: 1\r\n    },\r\n\r\n    /**\r\n     * @type         string\r\n     * @description  需要裁剪的图片地址\r\n     */\r\n    imageSrc: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n\r\n    /**\r\n     * @type         number\r\n     * @description  裁剪区域的宽度\r\n     */\r\n    cropperWidth: {\r\n      type: Number,\r\n      value: 720\r\n    },\r\n\r\n    /**\r\n     * @type          number\r\n     * @description   最小裁剪的范围\r\n     */\r\n    minCropperW: {\r\n      type: Number,\r\n      value: 100\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    /**\r\n     * @type         boolean\r\n     * @description  图片在进行网络请求完成之后显示，showImg用于控制图片显示时机\r\n     */\r\n    showImg: false,\r\n\r\n    /**\r\n     * @\r\n     */\r\n    // 动态的宽高\r\n    cropperW: null,\r\n    cropperH: null,\r\n\r\n    // 图片缩放值\r\n    scaleP: 0,\r\n    // 裁剪框 宽高\r\n    cutL: 0,\r\n    cutT: 0,\r\n    cutB: 0,\r\n    cutR: 0,\r\n\r\n    qualityWidth: null,\r\n    innerAspectRadio: null,\r\n\r\n    filePath: null\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    close () {\r\n      wx.hideLoading()\r\n      this.triggerEvent('close')\r\n    },\r\n\r\n    /**\r\n     * 初始化变量信息\r\n     */\r\n    initStaticData () {\r\n      this.drag = {\r\n        CUT_L: null,  // 初始化拖拽元素的left值\r\n        CUT_T: null,  // ...top值\r\n        CUT_R: null,  // ...right值\r\n        CUT_B: null,  // ...bottom值\r\n\r\n        CUT_W: null,  // 初始化拖拽元素的宽度\r\n        CUT_H: null,  // 初始化拖拽元素的高度\r\n\r\n        IS_TOUCH_CONTENT: false,  // 是否是可拖动的状态（拖拽裁剪框）\r\n        IS_TOUCH_SIDE: false,  // 是否可以拖拽边框\r\n        IS_NO_DRAG: false, \r\n\r\n        // 拖拽区域的时候设置\r\n        TOUCH_OFFSET_X: null, // 手按下相对于裁剪框左边的距离\r\n        TOUCH_OFFSET_Y: null, // 手按下相对于裁剪框上边的距离\r\n\r\n        TOUCH_MAX_MOVE_SECTION_X: null, // 移动区域的时候移动的x方向最大区间\r\n        TOUCH_MAX_MOVE_SECTION_Y: null, // 移动区域的时候移动的y方向最大区间\r\n\r\n        MOVE_PAGE_X: null,  // 手移动的时候x的位置\r\n        MOVE_PAGE_Y: null,  // 手移动的时候Y的位置\r\n\r\n        SPACE_TOP_POSITION: null,\r\n        SPACE_LEFT_POSITION: null,\r\n        SPACE_RIGHT_POSITION: null,\r\n        SPACE_BOTTOM_POSITION: null\r\n      }\r\n\r\n      this.conf = {\r\n        // 图片比例\r\n        IMG_RATIO: null,\r\n\r\n        // 图片实际宽高\r\n        IMG_REAL_W: null,   // 图片实际的宽度\r\n        IMG_REAL_H: null,   // 图片实际的高度\r\n\r\n        // 裁剪除黑色区域以内的高度\r\n        CROPPER_HEIGHT: null,   // 图片背景区域宽度\r\n        CROPPER_WIDTH: null,    // 图标背景区域高度\r\n\r\n        // 设置最小裁剪宽度高度\r\n        CUT_MIN_W: null,  // 最小限制多宽\r\n        CUT_MIN_H: null,  // 最小限制多高\r\n\r\n        // 裁剪图片区域的信息\r\n        // CROPPER_IMG_W: null,    // 也就是 data.cropperW\r\n        // CROPPER_IMG_H: null,    // 也就是 data.cropperH\r\n\r\n        // 移动的比例\r\n        DRAG_MOVE_RATIO: 750 / wx.getSystemInfoSync().windowWidth,  //移动时候的比例,\r\n\r\n        INIT_DRAG_POSITION: 0,    // 初始化屏幕宽度和裁剪区域的宽度之差，用于设置初始化裁剪的宽度\r\n        DRAW_IMAGE_W: null,       // 设置生成的图片宽度\r\n\r\n        // 最大可显示得图片宽度，需要设定最大值，否则安卓部分机器会闪退, 控制qualityWidth的最大值\r\n        MAX_QW: 2550,\r\n\r\n        /**\r\n         * 最小裁剪宽度  由于设置了裁剪的UI样式，裁剪的宽高必须要有最小宽度，这个宽度是裁剪长或者宽的最短一方的宽度\r\n         * 如 400 200\r\n         * 那么如果只能设置为100的时候\r\n         * 那么最小缩放到200 100的效果，之后只能放大不能缩小\r\n         */\r\n        MIN_CROPPER_DIS: 100\r\n      }\r\n    },\r\n\r\n    /**\r\n     * 选择本地图片\r\n     * 基于底部中间的按钮的点击事件\r\n     */\r\n    getImage: function () {\r\n      const _this = this\r\n      wx.chooseImage({\r\n        success: function (res) {\r\n          _this.setData({\r\n            isShowImg: false,\r\n            filePath: res.tempFilePaths[0],\r\n          })\r\n          _this.loadImage(_this.data.filePath);\r\n        },\r\n      })\r\n    },\r\n\r\n    /**\r\n     * 初始化加载图片\r\n     */\r\n    loadImage (src) {\r\n      const _this = this\r\n\r\n      wx.showLoading({\r\n        title: '图片加载中...',\r\n      })\r\n      console.log(this.properties.imageSrc)\r\n      wx.getImageInfo({\r\n        src: src ? src : this.properties.imageSrc,\r\n        success: function (res) {\r\n          /**\r\n           * 获取图片真实宽高\r\n           * 设置DRAW_IMAGE_W\r\n           */\r\n          _this.conf.DRAW_IMAGE_W = _this.conf.IMG_REAL_W = res.width\r\n          _this.conf.IMG_REAL_H = res.height\r\n          _this.conf.IMG_RATIO = Number((_this.conf.IMG_REAL_W / _this.conf.IMG_REAL_H).toFixed(5))\r\n          _this.conf.CROPPER_HEIGHT = Math.ceil(_this.properties.cropperWidth / _this.conf.IMG_RATIO)\r\n\r\n          const scaleP = Number((_this.conf.IMG_REAL_W / _this.properties.cropperWidth).toFixed(5))\r\n          const qualityWidth = _this.conf.DRAW_IMAGE_W > _this.conf.MAX_QW ? _this.conf.MAX_QW : _this.conf.DRAW_IMAGE_W\r\n          // const MIN_RANG\r\n          const p = _this.initPosition()\r\n\r\n          // 根据图片的宽高显示不同的效果 保证图片可以正常显示 (横屏)\r\n          console.log(_this.conf.IMG_RATIO)\r\n          console.log(_this.conf)\r\n          console.log(_this.drag)\r\n          console.log(_this.data)\r\n          console.log(p)\r\n          if (_this.conf.IMG_RATIO >= 1) {\r\n            _this.conf.CROPPER_WIDTH = _this.properties.cropperWidth\r\n            _this.setData ({\r\n              cropperW: _this.properties.cropperWidth,\r\n              cropperH: _this.conf.CROPPER_HEIGHT,\r\n\r\n              // 初始化left right\r\n              cutL: p.left,\r\n              cutT: p.top,\r\n              cutR: p.right,\r\n              cutB: p.bottom,\r\n\r\n              // 图片缩放值\r\n              scaleP,\r\n              qualityWidth,\r\n              innerAspectRadio: _this.conf.IMG_RATIO,\r\n              filePath: res.path\r\n            })\r\n          } else {\r\n            // 竖屏初始化\r\n            _this.setData ({\r\n              cropperW: _this.conf.CROPPER_WIDTH,\r\n              cropperH: _this.conf.CROPPER_HEIGHT,\r\n\r\n              // 初始化left right\r\n              cutL: p.left,\r\n              cutT: p.top,\r\n              cutR: p.right,\r\n              cutB: p.bottom,\r\n\r\n              // 图片缩放值\r\n              scaleP,\r\n              qualityWidth,\r\n              innerAspectRadio: _this.conf.IMG_RATIO,\r\n              filePath: res.path\r\n            })\r\n          }\r\n\r\n          // 设置裁剪最小限制\r\n          _this.setMinCutInfo()\r\n\r\n          _this.setData({\r\n            showImg: true\r\n          })\r\n\r\n          wx.hideLoading()\r\n        } \r\n      })\r\n    },\r\n\r\n    /**\r\n     * 点击完成裁剪图片并返回图片信息\r\n     * width 宽度\r\n     * height  高度\r\n     * url  图片的临时存储地址\r\n     */\r\n    getImageInfo() {\r\n      const _this = this\r\n      wx.showLoading({\r\n        title: '图片生成中...',\r\n      })\r\n      this.drag.IS_NO_DRAG = true\r\n      // 将图片写入画布\r\n      const ctx = wx.createCanvasContext('wxCropperCanvas', _this)\r\n      const w = this.data.qualityWidth\r\n      const h = Math.ceil(this.data.qualityWidth / this.data.innerAspectRadio)\r\n      ctx.drawImage(_this.data.filePath, 0, 0, w, h)\r\n      ctx.draw(true, () => {\r\n        // 获取画布要裁剪的位置和宽度   均为百分比 * 画布中图片的宽度    保证了在微信小程序中裁剪的图片模糊  位置不对的问题\r\n        const canvasW = Math.ceil(((_this.data.cropperW - _this.data.cutL - _this.data.cutR) / _this.data.cropperW) * w)\r\n        const canvasH = Math.ceil(((_this.data.cropperH - _this.data.cutT - _this.data.cutB) / _this.data.cropperH) * h)\r\n        const canvasL = Math.ceil((_this.data.cutL / _this.data.cropperW) * w)\r\n        const canvasT = Math.ceil((_this.data.cutT / _this.data.cropperH) * h)\r\n        console.log(canvasW, canvasH, canvasL, canvasT)\r\n        // 生成图片\r\n        wx.canvasToTempFilePath({\r\n          x: canvasL,\r\n          y: canvasT,\r\n          width: canvasW,\r\n          height: canvasH,\r\n          destWidth: canvasW,\r\n          destHeight: canvasH,\r\n          quality: 0.9,\r\n          canvasId: 'wxCropperCanvas',\r\n          success: function (res) {\r\n            // console.log(res.tempFilePath)\r\n            const img = {\r\n              path: res.tempFilePath,\r\n              width: canvasW,\r\n              height: canvasH\r\n            }\r\n            _this.triggerEvent('close', img)\r\n          },\r\n          complete: function () {\r\n            // 结束之后可拖拽放大缩小\r\n            // 关闭loading\r\n            wx.hideLoading()\r\n            _this.drag.IS_NO_DRAG = false\r\n          }\r\n        }, _this)\r\n      })\r\n    },\r\n\r\n    /**\r\n     * 设置最小裁剪宽度高度限制\r\n     */\r\n    setMinCutInfo () {\r\n      this.conf.CUT_MIN_W = this.properties.minCropperW\r\n      if (this.properties.cutRatio) {\r\n        this.conf.CUT_MIN_H = this.conf.CUT_MIN_W / this.properties.cutRatio\r\n        console.log('this.conf.CUT_MIN_H', this.conf.CUT_MIN_H)\r\n        return\r\n      }\r\n      this.conf.CUT_MIN_H = this.conf.CUT_MIN_W\r\n      console.log('this.conf.CUT_MIN_H', this.conf.CUT_MIN_H)\r\n    },\r\n\r\n    /**\r\n     * 初始化裁剪位置\r\n     * 需要 cutRatio 来判断\r\n     * @return 返回裁剪的left, right, top bottom的值\r\n     */\r\n    initPosition () {\r\n      // 定义返回的对象\r\n      let left = 0,\r\n          right = 0,\r\n          top = 0,\r\n          bottom = 0\r\n      // cutRatio为0 且为横行  则为不等比裁剪\r\n      if (this.properties.cutRatio === 0 && this.conf.IMG_RATIO >= 1) {\r\n        return { left, right, top, bottom }\r\n      }\r\n\r\n      // 如果图片宽度大于等于高度（横向）\r\n      if (this.conf.IMG_RATIO >= 1) {\r\n        // 获取基本宽度\r\n        // 图片显示区域比裁剪比例大的时候\r\n        if (this.conf.IMG_RATIO >= this.properties.cutRatio) {\r\n          // left的值\r\n          let leftRight = Math.ceil((this.properties.cropperWidth - (this.conf.CROPPER_HEIGHT * this.properties.cutRatio)) / 2)\r\n          return {\r\n            left: leftRight,\r\n            right: leftRight,\r\n            top: 0,\r\n            bottom: 0\r\n          }\r\n        }\r\n        // 否则\r\n        const bottomTop = Math.ceil((this.conf.CROPPER_HEIGHT  - (this.properties.cropperWidth / this.properties.cutRatio)) / 2)\r\n        return {\r\n          left: 0,\r\n          right: 0,\r\n          top: bottomTop,\r\n          bottom: bottomTop\r\n        }\r\n      }\r\n\r\n      // 如果图片宽度小于高度 (竖向)\r\n      // const r = _this.properties.cropperRatio > _this.conf.IMG_RATIO ? _this.properties.cropperRatio : _this.conf.IMG_RATIO\r\n      if (this.properties.cropperRatio > this.conf.IMG_RATIO) {\r\n        this.conf.CROPPER_WIDTH = this.properties.cropperWidth / this.properties.cropperRatio * this.conf.IMG_RATIO\r\n        this.conf.CROPPER_HEIGHT = this.properties.cropperWidth / this.properties.cropperRatio\r\n      } else {\r\n        this.conf.CROPPER_WIDTH = this.properties.cropperWidth\r\n        this.conf.CROPPER_HEIGHT = this.properties.cropperWidth / this.conf.IMG_RATIO\r\n      }\r\n      // 定义四个位置  如果不比例裁剪\r\n      if (this.properties.cutRatio === 0) return { left, right, top, bottom }\r\n      // 否则\r\n\r\n      if (this.conf.IMG_RATIO >= this.properties.cutRatio) {\r\n        let leftRight = Math.ceil((this.conf.CROPPER_WIDTH - (this.conf.CROPPER_HEIGHT * this.properties.cutRatio)) / 2)\r\n        return {\r\n          left: leftRight,\r\n          right: leftRight,\r\n          top: 0,\r\n          bottom: 0\r\n        }\r\n      }\r\n      const bottomTop = Math.ceil((this.conf.CROPPER_HEIGHT  - (this.conf.CROPPER_WIDTH / this.properties.cutRatio)) / 2)\r\n      return {\r\n        left: 0,\r\n        right: 0,\r\n        top: bottomTop,\r\n        bottom: bottomTop\r\n      }\r\n    },\r\n\r\n    /**\r\n     * 裁剪框的拖动事件\r\n     */\r\n    contentDragStart (e) {\r\n      if (this.drag.IS_NO_DRAG) return\r\n      this.drag.IS_TOUCH_CONTENT = true\r\n\r\n      this.drag.TOUCH_OFFSET_X = (e.touches[0].pageX * this.conf.DRAG_MOVE_RATIO - this.data.cutL)\r\n      this.drag.TOUCH_OFFSET_Y = (e.touches[0].pageY * this.conf.DRAG_MOVE_RATIO - this.data.cutT)\r\n\r\n      /**\r\n       * 获取可移动的最大值 xy方向\r\n       */\r\n      const cc = this.cropperCurrentInfo()\r\n      this.drag.TOUCH_MAX_MOVE_SECTION_X = cc.x\r\n      this.drag.TOUCH_MAX_MOVE_SECTION_Y = cc.y\r\n    },\r\n\r\n    /**\r\n     * 获取裁剪区域信息\r\n     */\r\n    cropperCurrentInfo () {\r\n      const x = this.data.cutL + this.data.cutR\r\n      const y = this.data.cutT + this.data.cutB\r\n\r\n      // 获取拖拽元素的宽高\r\n      this.drag.CUT_W = this.data.cropperW - x\r\n      this.drag.CUT_H = this.data.cropperH - y\r\n\r\n      // 返回x, y\r\n      return {\r\n        x,\r\n        y\r\n      }\r\n    },\r\n\r\n    /**\r\n     * 裁剪框拖动\r\n     */\r\n    contentDragMove (e) {\r\n      if (this.drag.IS_NO_DRAG) return\r\n      if (!this.drag.IS_TOUCH_CONTENT) return\r\n      const MOVE_X = e.touches[0].pageX * this.conf.DRAG_MOVE_RATIO - this.drag.TOUCH_OFFSET_X\r\n      const MOVE_Y = e.touches[0].pageY * this.conf.DRAG_MOVE_RATIO - this.drag.TOUCH_OFFSET_Y\r\n\r\n      const drag_x = Math.min(this.drag.TOUCH_MAX_MOVE_SECTION_X, Math.max(0, MOVE_X))\r\n      const drag_y = Math.min(this.drag.TOUCH_MAX_MOVE_SECTION_Y, Math.max(0, MOVE_Y))\r\n\r\n      this.setData({\r\n        cutL: Math.ceil(drag_x),\r\n        cutR: Math.ceil(this.data.cropperW - this.drag.CUT_W - drag_x),\r\n        cutT: Math.ceil(drag_y),\r\n        cutB: Math.ceil((this.data.cropperH - this.drag.CUT_H - drag_y))\r\n      })\r\n\r\n      // 需要初始化\r\n      this.drag.TOUCH_OFFSET_X = (e.touches[0].pageX * this.conf.DRAG_MOVE_RATIO - this.data.cutL)\r\n      this.drag.TOUCH_OFFSET_Y = (e.touches[0].pageY * this.conf.DRAG_MOVE_RATIO - this.data.cutT)\r\n    },\r\n\r\n    /**\r\n     * 裁剪框拖动结束\r\n     */\r\n    contentTouchEnd () {\r\n      this.drag.IS_TOUCH_CONTENT = false\r\n    },\r\n\r\n    /**\r\n     * 裁剪框4个方向的拖拽\r\n     */\r\n    sideDragStart (e) {\r\n      if (this.drag.IS_NO_DRAG) return\r\n      this.drag.IS_TOUCH_SIDE = true\r\n      this.drag.MOVE_PAGE_X = e.touches[0].pageX\r\n      this.drag.MOVE_PAGE_Y = e.touches[0].pageY\r\n\r\n      // 初始化设置\r\n      this.conf.CUT_T = this.data.cutT\r\n      this.conf.CUT_L = this.data.cutL\r\n      this.conf.CUT_R = this.data.cutR\r\n      this.conf.CUT_B = this.data.cutB\r\n\r\n      // 初始化最大移动区域\r\n      this.drag.SPACE_TOP_POSITION = this.conf.CROPPER_HEIGHT - this.conf.CUT_B - this.conf.CUT_MIN_H\r\n      this.drag.SPACE_BOTTOM_POSITION = this.conf.CROPPER_HEIGHT - this.conf.CUT_T - this.conf.CUT_MIN_H\r\n      this.drag.SPACE_RIGHT_POSITION = this.conf.CROPPER_WIDTH - this.conf.CUT_L - this.conf.CUT_MIN_W\r\n      this.drag.SPACE_LEFT_POSITION = this.conf.CROPPER_WIDTH - this.conf.CUT_R - this.conf.CUT_MIN_W\r\n    },\r\n    \r\n    /**\r\n     *  拖拽中\r\n     */\r\n    sideDragMove (e) {\r\n      if (this.drag.IS_NO_DRAG) return\r\n      if (!this.drag.IS_TOUCH_SIDE) return\r\n      const type = e.target.dataset.drag\r\n      if (this.properties.cutRatio === 0) {\r\n        this.sideDragMoveDefault(e, type)\r\n      } else {\r\n        this.sideDragMoveConst(e, type)\r\n      }\r\n    },\r\n\r\n    /**\r\n     * 拖拽结束\r\n     */\r\n    sideDragEnd () {\r\n      this.drag.IS_TOUCH_SIDE = false\r\n      console.log('sideDragEnd')\r\n    },\r\n\r\n    /**\r\n     * 开始拖拽\r\n     * 等比例的拖拽方式\r\n     */\r\n    sideDragMoveConst (e, type) {\r\n      const xLength = (e.touches[0].pageX - this.drag.MOVE_PAGE_X) * this.conf.DRAG_MOVE_RATIO\r\n      const yLength = (e.touches[0].pageY - this.drag.MOVE_PAGE_Y) * this.conf.DRAG_MOVE_RATIO\r\n      switch (type) {\r\n        case 'top':\r\n          let top = this.conf.CUT_T + yLength\r\n          top = Math.ceil(top >= this.drag.SPACE_TOP_POSITION ? this.drag.SPACE_TOP_POSITION : top)\r\n\r\n          let topL = this.conf.CUT_L + yLength * this.properties.cutRatio\r\n          topL = Math.ceil(topL >= this.drag.SPACE_LEFT_POSITION ? this.drag.SPACE_LEFT_POSITION : topL)\r\n\r\n          if (topL < 0) {\r\n            if (this.data.cutT <= 0) return\r\n            if (this.data.cutL >= 0) return\r\n            this.setData({\r\n              cutL: 0\r\n            })\r\n            return\r\n          }\r\n\r\n          if (top <= 0) {\r\n            this.setData({\r\n              cutT: 0\r\n            })\r\n            return\r\n          }\r\n\r\n          this.setData({\r\n            cutT: top,\r\n            cutL: topL\r\n          })\r\n          break;\r\n        case 'left':\r\n          let left = this.conf.CUT_L + xLength\r\n          left = Math.ceil(left >= this.drag.SPACE_LEFT_POSITION ? this.drag.SPACE_LEFT_POSITION : left)\r\n\r\n          let leftB = this.conf.CUT_B + xLength / this.properties.cutRatio\r\n          leftB = Math.ceil(leftB >= this.drag.SPACE_BOTTOM_POSITION ? this.drag.SPACE_BOTTOM_POSITION : leftB)\r\n\r\n          console.log(leftB)\r\n          console.log(left)\r\n          if (leftB < 0) {\r\n            if (this.data.cutL <= 0) return\r\n            if (this.data.cutB >= 0) return\r\n            this.setData({\r\n              cutB: 0\r\n            })\r\n            return\r\n          }\r\n\r\n          if (left <= 0) {\r\n            this.setData({\r\n              cutL: 0\r\n            })\r\n            return\r\n          }\r\n\r\n          this.setData({\r\n            cutL: left,\r\n            cutB: leftB\r\n          })\r\n          break;\r\n        case 'bottom':\r\n          let bottom = this.conf.CUT_B - yLength\r\n          bottom = Math.ceil(bottom >= this.drag.SPACE_BOTTOM_POSITION ? this.drag.SPACE_BOTTOM_POSITION : bottom)\r\n\r\n          let bottomR = this.conf.CUT_R - yLength * this.properties.cutRatio\r\n          bottomR = Math.ceil(bottomR >= this.drag.SPACE_RIGHT_POSITION ? this.drag.SPACE_RIGHT_POSITION : bottomR)\r\n\r\n          if (bottomR < 0) {\r\n            if (this.data.cutB <= 0) return\r\n            if (this.data.cutR >= 0) return\r\n            this.setData({\r\n              cutR: 0\r\n            })\r\n            return\r\n          }\r\n\r\n          if (bottom <= 0) {\r\n            this.setData({\r\n              cutB: 0\r\n            })\r\n            return\r\n          }\r\n\r\n          this.setData({\r\n            cutR: bottomR,\r\n            cutB: bottom\r\n          })\r\n          break;\r\n        case 'right':\r\n          let right = this.conf.CUT_R - xLength\r\n          right = Math.ceil(right >= this.drag.SPACE_RIGHT_POSITION ? this.drag.SPACE_RIGHT_POSITION : right)\r\n\r\n          let rightT = this.conf.CUT_T - xLength / this.properties.cutRatio\r\n          rightT = Math.ceil(rightT >= this.drag.SPACE_TOP_POSITION ? this.drag.SPACE_TOP_POSITION : rightT)\r\n\r\n          if (rightT < 0) {\r\n            if (this.data.cutR <= 0) return\r\n            if (this.data.cutT >= 0) return\r\n            this.setData({\r\n              cutT: 0\r\n            })\r\n            return\r\n          }\r\n\r\n          if (right <= 0) {\r\n            this.setData({\r\n              cutR: 0\r\n            })\r\n            return\r\n          }\r\n\r\n          this.setData({\r\n            cutR: right,\r\n            cutT: rightT\r\n          })\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * 非等比例拖拽的操作\r\n     */\r\n    sideDragMoveDefault (e, type) {\r\n      const xLength = (e.touches[0].pageX - this.drag.MOVE_PAGE_X) * this.conf.DRAG_MOVE_RATIO\r\n      const yLength = (e.touches[0].pageY - this.drag.MOVE_PAGE_Y) * this.conf.DRAG_MOVE_RATIO\r\n      switch (type) {\r\n        case 'top':\r\n          let top = this.conf.CUT_T + yLength\r\n          top = top <= 0 ? 0 : top\r\n          top = Math.ceil(top >= this.drag.SPACE_TOP_POSITION ? this.drag.SPACE_TOP_POSITION : top)\r\n          this.setData({\r\n            cutT: top\r\n          })\r\n          break;\r\n        case 'bottom':\r\n          let bottom = this.conf.CUT_B - yLength\r\n          bottom = bottom <= 0 ? 0 : bottom\r\n          bottom = Math.ceil(bottom >= this.drag.SPACE_BOTTOM_POSITION ? this.drag.SPACE_BOTTOM_POSITION : bottom)\r\n          this.setData({\r\n            cutB: bottom\r\n          })\r\n          break;\r\n        case 'right':\r\n          let right = this.conf.CUT_R - xLength\r\n          right = right <= 0 ? 0 : right\r\n          right = Math.ceil(right >= this.drag.SPACE_RIGHT_POSITION ? this.drag.SPACE_RIGHT_POSITION : right)\r\n          this.setData({\r\n            cutR: right\r\n          })\r\n          break;\r\n        case 'left':\r\n          let left = this.conf.CUT_L + xLength\r\n          left = left <= 0 ? 0 : left\r\n          left = Math.ceil(left >= this.drag.SPACE_LEFT_POSITION ? this.drag.SPACE_LEFT_POSITION : left)\r\n          this.setData({\r\n            cutL: left\r\n          })\r\n          break;\r\n        case 'rightBottom':\r\n          let rightBottomR = this.conf.CUT_R - xLength\r\n          rightBottomR = rightBottomR <= 0 ? 0 : rightBottomR\r\n          rightBottomR = Math.ceil(rightBottomR >= this.drag.SPACE_RIGHT_POSITION ? this.drag.SPACE_RIGHT_POSITION : rightBottomR)\r\n\r\n          let rightBottomB = this.conf.CUT_B - yLength\r\n          rightBottomB = rightBottomB <= 0 ? 0 : rightBottomB\r\n          rightBottomB = Math.ceil(rightBottomB >= this.drag.SPACE_BOTTOM_POSITION ? this.drag.SPACE_BOTTOM_POSITION : rightBottomB)\r\n          this.setData({\r\n            cutB: rightBottomB,\r\n            cutR: rightBottomR\r\n          })\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    },\r\n  },\r\n  \r\n  created: function () {\r\n    this.initStaticData()\r\n    // console.log(this.drag)\r\n    // console.log(this.conf)\r\n    console.log(this.data)\r\n    console.log(this.conf.DRAG_MOVE_RATIO)\r\n  },\r\n\r\n  attached: function () {\r\n    console.log('attached')\r\n    this.loadImage()\r\n  },\r\n\r\n  ready: function () {\r\n    console.log('ready')\r\n  },\r\n\r\n  moved: function () {\r\n    console.log('moved')\r\n  },\r\n\r\n  detached: function () {\r\n    console.log('detached')\r\n  }\r\n})\r\n"]}